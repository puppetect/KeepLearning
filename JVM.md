# JVM

## 基本结构

JVM由三个主要的子系统构成
- 类加载子系统
- 运行时数据区（内存结构）
- 执行引擎

运行时数据区
线程共有：
    方法区(Method Area) 静态变量、常量、类信息（构造方法/接口定义）、运行时常量池
    堆(Heap) 存放对象实例
线程私有：
    虚拟机栈：栈帧
    本地方法栈
    程序计数器

栈帧(一个栈帧对应一个方法)
1. 局部变量表（存储方法局部变量和引用类型）
2. 操作数栈（所有操作都在此执行）
3. 动态链接 （把符号引用转化成直接引用）
4. 方法出口（指向方法调用者的内存地址）

## 调优工具

Jinfo 查看正在运行的java程序的扩展参数和系统属性
查看jvm的参数
```
jinfo -flags 进程id
```
查看java系统属性  等同于System.getProperties()
```
jinfo -syspros 进程id
```

Jstat 查看堆内存各部分的使用量，以及加载类的数量。
```
jstat [-命令选项][vmid][间隔时间/毫秒][查询次数]
如 jstat -gc 进程id
```

Jmap 查看内存信息
堆的对象统计
```
jmap -histo 进程id > xxx.txt
```
堆内存dump
```
jmap -dump:format=b,file=temp.hprof
```
也可以设置在内存溢出时自动导出dump文件（内存过大可能会导不出来）
1. -XX:+HeapDumpOnOutOfMemoryError
2. -XX:HeapDumpPath=输出路径
```
-Xms10m -Xmx10m -XX:+PirntGCDetails -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=d:\oomdump.dump
```

Jstack 生成java虚拟机当前时刻的线程快照

##  类加载机制

#### 类的生命周期
1. 加载 将.class文件从磁盘读到内存
2. 连接
    2.1 验证
        验证字节码文件的正确性（如class文件格式、元数据、字节码、符号饮用的验证）
    2.2 准备
        给类的静态变量分配内存，并赋予默认值
    2.3 解析
        类装载器装入类所引用的其他所有类（静态链接）
3. 初始化
    为类的静态变量赋予正确的初始值，之前准备阶段赋予的是默认值，此时赋予的才是编程者为变量分配的初始值，执行静态代码块。
4. 使用
5. 卸载

#### 类加载器的种类
java中的类遵循**按需加载**。它可以使java类动态加载到jvm中运行，即可在程序运行时再加载类，提供了很灵活的动态加载方式。
**启动类加载器(Bootstrap ClassLoader)**
负责加载JRE的核心类库，如JRE目标下的rt.jar, charset.jar等
**扩展类加载器(Extension Classloader)**
负责加载JRE扩展目录ext中jar类包
**系统类加载器(Application ClassLoader)**
负责加载ClassPath路径下的类包
**用户自定义加载器(User ClassLoader)**
负责加载用户自定义路径下的类包

#### 类加载机制
**全盘负责委托机制**
当一个ClassLoader加载一个类的时候，除非显示的使用另一个ClassLoader，该类所依赖和引用的类也由这个ClassLoader载入
**双亲委派机制**
指先委托父类加载器寻找目标类，在找不到的情况下在自己的路径中查找病载入目标类
双亲委派模式的优势
- 沙箱安全机制：比如自己写的String.class类就不会被加载，这样可以防止核心库被随意篡改
- 避免类的重复加载：当父ClassLoader已经加载了该类的时候，就不需要子ClassLoader再加载一次



## GC算法和收集器
#### 如何判断对象可以被回收
堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡（即不能再被任何途径使用）

**引用计数法**
给对象添加一个引用计数器，每当有一个地方引用，计数器就加1。当引用失效，计数器就减1.任何时候计数器为0的对象就是不可能再被使用的。
这个方法实现简单，效率高，但是目前主流的虚拟机中没有选择这个算法来管理内存，最主要的原因是它难以解决对象之间循环引用。

**可达性分析算法**
这个算法的基本思想就是通过一系列的称为“GC Roots"的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连的话，则证明此对象是不可用的。
GC Roots根节点： 类加载器、Thread、虚拟机栈的局部变量表、static成员、常量引用、本地方法栈的变量等等

**[面试]如何判断一个常量是废弃常量？**
假如在常量池中存在字符串“abc”，如果当前没有任何string对象引用该字符串常量的话，就说明常量”abc“就是废弃常量，如果这时发生内存回收而且有必要的话，”abc“就会被系统清理出常量池。
**[面试]如何判断一个类是无用的类**
需要满足以下三个条件：
- 该类所有的实例都已经被回收，也就是java堆中不存在该类的任何实例
- 加载该类的ClassLoader已经被回收
- 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射反问该对象的方法。
虚拟机可以堆满足上述3个条件的无用类进行回收。这里仅仅是“可以”，而不是和对象一样不适用了就必然会回收。

#### 垃圾回收算法
**标记-清除算法**
它是最基础的收集算法，这个算法分为两个阶段，标记和清除，首先标记处所有需要回收的对象，在标记完成后统一回收被标记的对象。有两个不足：效率低，空间碎片
**复制算法**
把内存分为大小相同的两块，每次只使用其中的一块。当这一块的内存使用完后，将当中还存活的对象复制到另一块去，然后把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收
**标记-整理算法**
根据老年代的特点提出的一种标记算法，标记过程和“标记-清除”算法一样，但之后不是直接对可回收对象进行回收，而是将存活的对象向一端移动，然后直接清除掉边界外的内存。
**分代收集算法**
所有商用虚拟机的垃圾收集器都采用分代收集算法。它是根据存活周期将内存分为几块，包括新生代和老年代。新生代中，每次收集都有大量对象死去，所以选择复制算法。而老年代的对象存活几率较高，而且没有额外的空间对它进行分配担保，所以选用“标记整理” 算法进行垃圾收集。

#### 垃圾收集器

**Serial收集器**
串行收集器。单线程收集器，只会使用一条线程去完成垃圾收集工作，同时暂停其他所有工作线程直到收集结束。
新生代采用复制算法，老年代采用标记-整理算法。
对于运行在Client模式下的虚拟机来说是一个不错的选择。

**ParNew收集器**
就是Serial收集器的多线程版本。
新生代采用复制算法，老年代采用标记-整理算法。
它是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，只有它能与CMS收集器配合工作。

**Parallel Scanvenge收集器**
类似ParNew收集器，更关注吞吐量，提供很多工具帮助用户找到合适的停顿时间或最大吞吐量（吞吐量就是cpu中用于运行用户代码的时间与cpu总消耗时间的比例）

**Serial Old收集器**
Serial收集器的老年代版本。

**Parallel Old收集器**
Parallel Scanvenge收集器的老年代版本。

**CMS(Concurrent Mark Sweep)收集器**
并行和并发：
- 并行(Parallel)：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态
- 并发(Concurrent)：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个CPU上。
一种以最短回收停顿时间为目标的收集器，是HotSpot虚拟机第一款真正意义上的并发收集器，实现了垃圾收集线程与用户线程（基本上）同时工作。CMS是一种“标记-清除”算法实现，整个过程分为四个步骤：
- 初始标记(initial mark)：暂停所有其他线程，并记录下直接与root相连的对象，速度很快
- 并发标记(concurrent mark)：同时开启GC和用户线程，用一个闭包结构去记录可达对象。因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实效性，所以这个算法里会跟踪记录这些发生引用更新的地方。
- 重新标记(remark)：重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的标记记录，这个阶段的停顿时间一般回避初始标记阶段的时间稍长，但远远比并发标记阶段时间短。
- 并发清除(concurrent sweep)：开启用户线程，同时GC线程开始对标记的区域做清扫。
主要优点：并发收集、低停顿。
主要缺点：对cpu资源敏感，无法处理浮动垃圾，使用的回收算法（“标记-清除”）会产生大量碎片。

**G1(Garbage-First)收集器
官方推荐，一款面向服务器的垃圾收集器，主要针对配备多个处理器及大容量内存的机器。以极高概率满足GC停顿时间要求，同时还具备高吞吐量的特性。
具备以下特点：
- 并行和并发
- 分代收集
- 可预测的停顿
大致步骤：
- 初始标记
- 并发标记
- 最终标记
- 筛选回收

## 调优
JVM调优主要就是调整下面两个指标
停顿时间(Pause GC Time)：垃圾收集器做垃圾回收中断应用执行的时间。 -XX:MaxGCPauseMillis
吞吐量(Throughput)：用户代码运行时间和总时间的占比：-XX:GCTimeRatio=n

#### GC调优步骤
1. 打印GC日志
```
-XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintGCDateStamps -Xloggc:./gc.log
```
Tomcat可以直接加载JAVA_OPTS变量里
2. 分析日志得到关键性指标
3. 分析GC原因，调优JVM参数

可以用GCEasy对日志可视化


## 面试
1. mysql和tomcat是如何打破双亲委派机制的？tomcat自己的类加载机制？
2. 有几种引用？强软弱虚


## 参考
周志明 《深入理解java虚拟机》
